---
layout: post
title: 归并排序
date: 2018-11-16
tags: sort&find
---
### 概述
归并排序的主要思想还是分治法，将待排序数组不断细分为单个单元，在2个单元间进行排序，然后再两两逐渐递归合并成为更大的单元与其他合并而成的单元进行排序，最终合并成为原数组长度。
## 说明
归并的“分”可以直接使用递归的思路实现，这里主要讨论一下用于合并排序时的“治”法。
其步骤如下：<br>
（1）定义两个指针i和j分别指向数组的A和B的头部，即i=0,j=0；<br>
（2）比较a[i]和b[j]，将其中较小（升序排序）的一个追加到有序数组中，并使其对应的指针+1，然后继续比较，直到某个数组为空后，将另一个数组剩余值追加到有序数组中，最终合并成一个新的有序数组。
# 例子
假设存在已排序数组a{1,3,4,5}和b{2,7,9,10}，在合并排序时，定义数组temp作为有序数组空间，使得temp.length=a.length+b.length：
```
i=0,j=0; → a[i]<b[j]; → temp[0] = a[i] = 1; i++;
```
```
i=1,j=0; → a[i]>b[j]; → temp[1] = b[j] = 2; j++;
```
```
i=1,j=1; → a[i]<b[j]; → temp[2] = a[i] = 3; i++;
```
```
i=2,j=1; → a[i]<b[j]; → temp[3] = a[i] = 4; i++;
```
```
i=3,j=1; → a[i]<b[j]; → temp[4] = a[i] = 5; i++;
数组a扫描完毕，将数组b中的剩余值追加到temp中。
temp[5] = b[1] = 7;
temp[6] = b[2] = 9;
temp[7] = b[3] = 10;
```
### TimSort
听说jdk里面使用了一种叫timSort的优化方案进行排序，基本上是整合了归并排序和二分插入排序。目前没太看得懂，有待后续研究。
相关资料：[http://www.cnblogs.com/warehouse/p/9342279.html](http://www.cnblogs.com/warehouse/p/9342279.html)

## 暂记
1、判断了数组大小，小于32的使用二分插入，大于32的使用优化之后的归并。<br>
2、数组大小大于32时，将已有的有序区块定义为run，依次从前到后按以下规则合并run。<br>
runLen[i - 3] > runLen[i - 2] + runLen[i - 1] <br>
runLen[i - 2] > runLen[i - 1]<br>
3、优化了归并方法，先计算run1与run2的最小和最大区间，提前置于目标数组中，再将剩余的元素进行归并插入。<br>

## 疑问
1、countRunAndMakeAscending函数的意义。为什么要找到最大递增/递减的区间个数【元素个数】？<br>
2、什么叫run的最小长度minRun？有何作用？为什么是这种计算方式？<br>
a)如果数组大小为2的N次幂，则返回16（MIN_MERGE / 2）；<br>
b)  其他情况下，逐位向右位移（即除以2），直到找到介于16和32间的一个数；<br>
3、为什么最小递增长度小于minRun要用插入排序进行补充？如何补充？从哪里补充？
