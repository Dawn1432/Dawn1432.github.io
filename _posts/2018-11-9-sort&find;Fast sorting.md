---
layout: post
title: 快速排序
date: 2018-11-9
tags: sort&find
---

### 快速排序
现在这个年头，连快速排序都不会简直不好意思自己学过算法。
快速排序的基本思想是分治法，在每趟排序中，选择一个基准数，把所有比基准数小的移动到一边，比基准数大的移动到另一边。通常以第一个数为基准。
但是我竟然看过了2种快排方法，而且每趟排下来还不一样。
<img src='https://dawn1432.github.io\images\排序与查找\快速排序\无奈.jpg' align='margin-left' style=' width:75px;height:75px;margin:0;'/><br>
这里还是先给一个准备排序的原数组a:10，1，2，11，3，12，13，4，14，15，5，16。<br>
基准数：10；数组长度N：12。<br>
我先讲第一种，比较普遍的都讲的是这一种。
## 快速排序（一）一边挖坑一边填
定义标记i=0，j=11，基准k=10。<br>
（1）while(j-->i) if(a[j]<k) a[i] = a[j] break;<br>
（2）while(i++<j) if(a[i]>k) a[j] = a[i] break;<br>
以上循环break之后交替进行，直到i=j；然后a[i]/a[j] = k;<br>
以上完成了第一趟排序，然后就是按照上面的规则分别对k左边和右边递归执行；<br>
第一趟；<br>
k = 10;<br>
a:5，1，2，11，3，12，13，4，14，15，X，16。<br>
a:5，1，2，X，3，12，13，4，14，15，11，16。<br>
a:5，1，2，4，3，12，13，X，14，15，11，16。<br>
a:5，1，2，4，3，X，13，12，14，15，11，16。<br>
令X=K;<br>
第一趟结果：a:5，1，2，4，3，10，13，12，14，15，11，16。<br>
后边都是一样，分开之后分别递归。

然后讲一讲看到的另一种排序思路。
## 快速排序（二）两端扫描交换
定义标记i=0，j=11，基准k=10。<br>
（1）
```
while(j-->i)
  if(a[j]<k)
    break;
```
（2）
```
while(i++<j)
  if(a[i]>k)
    break;
```
（3）
```
temp = a[j]
a[j]=a[i]
a[i]=temp;
```
（很简单的一个二值交换）<br>
（4）to （1）直到i=j；<br>
（5）
```
a[0] = a[i]; //或者a[0] = a[j];
a[i] = k; //或者a[j] = k;
```
（注意：为了保证最后与a[0]交换的值一定比a[0]小，所以一定是j先变化。）<br>
第一趟；<br>
红色：i；<br>
蓝色：j；<br>
绿色：汇合点；<br>
浅蓝色：基准；<br>
k = 10;<br>
a:10，1，2，<font color="#FF0000">5</font>，3，12，13，4，14，15，<font color="#0000FF">11</font>，16。11<-->5<br>
a:10，1，2，5，3，<font color="#FF0000">4</font>，13，<font color="#0000FF">12</font>，14，15，11，16。12<-->4<br>
a:<font color="#00FFFF">10</font>，1，2，5，3，<font color="#88FF">4</font>，13，12，14，15，11，16。<br>
a:<font color="#88FF">4</font>，1，2，5，3，<font color="#00FFFF">10</font>，13，12，14，15，11，16。10<-->4<br>
第一趟结果：a:4，1，2，5，3，10，13，12，14，15，11，16。<br>
后边都是一样，分开之后分别递归。

# 我们来对比一下
第一种：5，1，2，4，3，10，13，12，14，15，11，16。<br>
第二种：4，1，2，5，3，10，13，12，14，15，11，16。<br>
<img src='https://dawn1432.github.io\images\排序与查找\快速排序\无奈.jpg' align='margin-left' style=' width:75px;height:75px;margin:0;'/><br>

然鹅，这种固定选择基准的方法似乎在某些情况下并不能达到一个很好的排序效率，比如数组本来就是有序的，或者数组中存在重复元素。为应对这些问题，针对快排又提出了一些优化方案。
### 基元选择优化
## （一）随机基元选择
因为随机选取基元，所以不会总是出现劣割裂分隔，在一定程度上解决了顺序数组下的排序效率问题。
## （二）三数取中
原数组：<br>
a:10，1，2，11，3，12，13，4，14，15，5，16。<br>
（1）选择3个数a[0]=10，a[（N-1）/2]=12，a[N-1]=16。<br>
（2）对选择的3个数排序，这里刚好有序。<br>
（3）将中值a[（N-1）/2]=12放到数组首部。<br>
a:10，12，1，2，11，3，13，4，14，15，5，16。<br>
（4）除开已选择的3个数，对数组进行双向扫描，从左寻找比中值大的数，从右寻找比中值小的数，两两交换，最后将指针汇合点与中值交换。右边的指针先动。<br>
（注意：为了保证最后与中值交换的值一定比中值小，所以一定是j先变化。）<br>
第一趟；<br>
红色：i；<br>
蓝色：j；<br>
绿色：汇合点；<br>
浅蓝色：中值；<br>
a:10，12，1，2，11，3，<font color="#FF0000">13</font>，4，14，15，<font color="#0000FF">5</font>，16。<br>
a:10，<font color="#00FFFF">12</font>，1，2，11，3，5，<font color="#88FF">4</font>，14，15，13，16。13<-->5<br>
a:10，4，1，2，11，3，5，12，14，15，13，16。12<-->4<br>
（5）然后左右递归执行。<br>
三数取中有效地解决了顺序数组的排序效率，但是还是无法处理重复数组。
### 优化方法
## （一）三数取中+插入排序
当排序序列长度效率某一个值时，快排并没有插入排序效率高，通常我们选择N=10；所以，当子序列长度小于等于10时，使用插入排序。<br>
但是仍然不能处理重复数组。
## （二）三数取中+插入排序+key值聚集
在以上的模式下，每趟排序之后将key聚集到key的周围可以大大解决重复数组对排序效率的影响。<br>
<img src='https://dawn1432.github.io\images\排序与查找\快速排序\快排测试数据.png' align='margin-left' style=' width:800px;height:170px;margin:0;'/><br>
数据来自：[https://yq.aliyun.com/ziliao/384039](https://yq.aliyun.com/ziliao/384039)

### 快速排序进阶版
## （一）单端扫描快速排序
这里的单端扫描其实还是一个基础版，先讲一讲这种扫描基本思路，后面会以这种扫描思路为基础进行进阶。
每趟的操作如下：<br>
（1）选择一个中轴k。（以最左边为中轴）。<br>
（2）定义当前趟i，j，并使得最终i，j将原区间a[begin,end]分为三段，使得a[begin,i]<=k，a[i+1,j-1]>k，a[j,end]未知。最后将所有的未知数据转移到对应的区间中。i初始化指向中轴元素，j初始化指向第一个未知元素。当未知元素为空时，当前趟结束。<br>
（3）元素转移分为以下两种情况：<br>
1）a[j]>k；<br>
则j++。【此时，大于k的部分多了一个元素。】<br>
2）a[j]<=k；<br>
则i++，然后交换a[i]和a[j]，然j++。【此时，小于等于k的部分多了一个元素；大于等于k的部分的第一个元素移动到了最后一个，这个移动没有多余的意义，纯粹是为了保持区间特性。】<br>
（4）交换a[i]和a[0]。<br>
<img src='https://dawn1432.github.io\images\排序与查找\快速排序\单向扫描快排.png' align='margin-left' style=' width:800px;height:170px;margin:0;'/><br>
原数组：<br>
a:10，1，2，11，3，12，13，4，14，15，5，16。<br>
第一趟：<br>
k=10;
```
i=0,j=1; => a[j]<=k; => i++;swap(a[i],a[j]);j++;
结果:10，1，2，11，3，12，13，4，14，15，5，16。
```
```
i=1,j=2; => a[j]<=k;
结果:10，1，2，11，3，12，13，4，14，15，5，16。
```
```
i=2,j=3; => a[j]>k; => j++;
结果:10，1，2，11，3，12，13，4，14，15，5，16。
```
```
i=2,j=4; => a[j]<=k; => i++;swap(a[i],a[j]);j++;
结果:10，1，2，3，11，12，13，4，14，15，5，16。
```
```
i=3,j=5; => a[j]>k; => j++;
结果:10，1，2，3，11，12，13，4，14，15，5，16。
```
```
i=3,j=6; => a[j]>k; => j++;
结果:10，1，2，3，11，12，13，4，14，15，5，16。
```
```
i=3,j=7; => a[j]<=k; => i++;swap(a[i],a[j]);j++;
结果:10，1，2，3，4，12，13，11，14，15，5，16。
```
```
i=4,j=8; => a[j]>k; => j++;
结果:0，1，2，3，4，12，13，11，14，15，5，16。
```
```
i=4,j=9; => a[j]>k; => j++;
结果:10，1，2，3，4，12，13，11，14，15，5，16。
```
```
i=4,j=10; => a[j]<=k; => i++;swap(a[i],a[j]);j++;
结果:10，1，2，3，4，5，13，11，14，15，12，16。
```
```
i=5,j=11; => a[j]>k; => j++;
结果:10，1，2，3，4，5，13，11，14，15，12，16。
```
```
最后交换a[0]和a[i]
结果：5，1，2，3，4，10，13，11，14，15，12，16。
```
然后就是分别递归了。
## （二）三向切分快速排序
每趟操作如下：
（1）选择一个中轴k。（以最左边为中轴）。<br>
（2）定义当前趟的i，j，h，并舍得最终将原区间a[begin,end]分为四段，使得a[begin,i-1]<k,a[i,k-1]=k,a[k,j-1]未知，a[j,end]>k。最后将所有的未知数据转移到对应的区间中。i初始化指向中轴元素，h初始化指向第一个未知元素，j初始化指向区间最后一个元素。当未知元素为空时，当前趟结束。<br>
（3）元素转移分为以下三种情况：<br>
1）a[h]<k；<br>
则交换a[i]和a[h]，i++，且h++。<br>
2）a[h] = k；<br>
则i++，且h++。<br>
3）a[h]>k；<br>
由于无法确认a[h]与a[j]的大小关系，所以还不能直接交换，此时，又分为以下三种情况：<br>
3.1）a[j]>k；<br>
则j--；<br>
3.2）a[j]=k；<br>
则交换a[j]和a[h]，h++。<br>
3.3）a[j]<k；<br>
则交换a[i]，a[j]，a[h]，如下：然后，j--，h++。
```
temp = a[i];
a[i] = a[j];
a[j] = a[h];
a[h] = temp;
```
<img src='https://dawn1432.github.io\images\排序与查找\快速排序\三向切分快排.png' align='margin-left' style=' width:800px;height:170px;margin:0;'/><br>
原数组：<br>
a:10，1，2，11，3，12，13，4，14，15，5，16。<br>
第一趟：<br>
k=10;
```
i=0,j=11;h=1; => a[h]<k; => swap(a[i],a[h]);h++;
结果:1，10，2，11，3，12，13，4，14，15，5，16。
```
```
i=1,j=11;h=2; => a[h]<k; => swap(a[i],a[h]);i++;h++;
结果:1，2，10，11，3，12，13，4，14，15，5，16。
```
```
i=2,j=11;h=3; => a[h]>k; => {
  j=11;
  a[j]>k; => j--;
  结果:1，2，10，11，3，12，13，4，14，15，5，16。
---------------------------------------------------------
  j=10;
  a[j]<k; => swap(a[i],a[j],a[h]);j--;h++;i++;
  结果:1，2，5，10，3，12，13，4，14，15，11，16。
---------------------------------------------------------
  }
```
```
i=3,j=9;h=4; => a[h]<k; => swap(a[i],a[h]);i++;h++;
结果:1，2，5，3，10，12，13，4，14，15，11，16。
```
```
i=4,j=9;h=5; => a[h]>k; => {
  j=9;
  a[j]>k; => j--;
  结果:1，2，5，3，10，12，13，4，14，15，11，16。
---------------------------------------------------------
  j=8;
  a[j]>k; => j--;
  结果:1，2，5，3，10，12，13，4，14，15，11，16。
---------------------------------------------------------
  j=7;
  a[j]<k; => swap(a[i],a[j],a[h]);j--;h++;i++;
  结果:1，2，5，3，4，10，13，12，14，15，11，16。
---------------------------------------------------------
  };
```
```
i=5,j=6,h=6; => a[h]>k; => {
  j=6;
  a[j]>k; => j--;
  结果:1，2，5，3，10，12，13，4，14，15，11，16。
  【由于j<h，所以当前趟结束】
}
```
然后就是分别递归了。
## （三）双轴快速排序
主要思想基本和三向切分一样，但是选择了两个轴通常选择数组的左端和右端。<br>
每趟操作如下：<br>
（1）选择双轴k1，k2。（左右端）比较k1和k2，若顺序不正确则交换k1和k2。<br>
（2）定义当前趟的i，j，h，并舍得最终将原区间a[begin,end]分为四段，使得a[begin,i]<k1,k1<=1a[i+1,k-1]<=k2,a[k,j-1]未知，a[j,end]>k2。最后将所有的未知数据转移到对应的区间中。i初始化指向中轴元素，h初始化指向第一个未知元素，j初始化指向区间最后一个元素。当未知元素为空时，当前趟结束。<br>
（3）同上，元素交换分为三种情况：<br>
1）a[h]<k1；<br>
则i++，交换a[i]和a[h]，h++；<br>
2）k1<=a[h]<=k2；<br>
则h++；<br>
3）a[h]>k2；<br>
由于无法确定a[h]与a[j]的大小关系，所以此时分三种情况：<br>
3.1）a[j]>k2；<br>
则j--；<br>
3.2）k1<=a[j]<=k2；
则交换a[h]和a[j]，j--，h++；
3.3）k1>a[j]；
则交换a[i]，a[j]，a[h]，如下：然后，j--，h++。
```
temp = a[i];
a[i] = a[j];
a[j] = a[h];
a[h] = temp;
```
（4）交换a[begin]和a[i]，交换a[end]和a[j]。
<img src='https://dawn1432.github.io\images\排序与查找\快速排序\双轴快排.png' align='margin-left' style=' width:800px;height:170px;margin:0;'/><br>
原数组：<br>【跟上面的原数组有点不一样】
a:10，1，2，11，3，12，16，4，14，15，5，13。<br>
第一趟：<br>
k1=10，k2=13;(顺序正确，不用交换)
```
i=0,j=11;h=1; => a[h]<k1; => i++;swap(a[i],a[h]);h++;
结果:10，1，2，11，3，12，16，4，14，15，5，13。
```
```
i=1,j=11;h=2; => a[h]<k1; => i++;swap(a[i],a[h]);h++;
结果:10，1，2，11，3，12，16，4，14，15，5，13。
```
```
i=2,j=11;h=3; => k1<=a[h]<=k2; => h++;
结果:10，1，2，11，3，12，16，4，14，15，5，13。
```
```
i=2,j=11;h=4; => a[h]<k1; => i++;swap(a[i],a[h]);h++;
结果:10，1，2，3，11，12，16，4，14，15，5，13。
```
```
i=3,j=11;h=5; => k1<=a[h]<=k2; => h++;
结果:10，1，2，3，11，12，16，4，14，15，5，13。
```
```
i=3,j=11;h=6; => k2<a[h]; => {
 j--;
 j=10;
 a[j]<k1; => swap(a[i],a[j],a[h]);h++;i++;
 结果:10，1，2，3，5，12，11，4，14，15，16，13。
}
```
```
i=4,j=10;h=7; => a[h]<k1; => i++;swap(a[i],a[h]);h++;
结果:10，1，2，3，5，4，11，12，14，15，16，13。
```
```
i=5,j=10;h=8; => k2<a[h]; => {
 j--;
 j=9;
 a[j]>k2;
 结果:10，1，2，3，5，4，11，12，14，15，16，13。
---------------------------------------------------------
 j--;
 j=8; 
 a[j]>k2;
 结果:10，1，2，3，5，4，11，12，14，15，16，13。
---------------------------------------------------------
 j--;
 j=7;
 结果:10，1，2，3，5，4，11，12，14，15，16，13。
 【由于j<h，所以当前趟结束】
---------------------------------------------------------
}
```
```
交换a[begin]和a[i]，交换a[end]和a[j]。【还是和a[h]交换？】
结果:4，1，2，3，5，10，11，12，13，15，16，14。
```
然后就是分三段递归了。