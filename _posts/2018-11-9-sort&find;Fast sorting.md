---
layout: post
title: 快速排序
date: 2018-11-9
tags: sort&find
---

### 快速排序
现在这个年头，连快速排序都不会简直不好意思自己学过算法。
快速排序的基本思想是分治法，在每趟排序中，选择一个基准数，把所有比基准数小的移动到一边，比基准数大的移动到另一边。通常以第一个数为基准。
但是我竟然看过了2种快排方法，而且每趟排下来还不一样。
<img src='https://dawn1432.github.io\images\排序与查找\快速排序\无奈.jpg' align='margin-left' style=' width:75px;height:75px;margin:0;'/><br>
这里还是先给一个准备排序的原数组a:10，1，2，11，3，12，13，4，14，15，5，16。<br>
基准数：10；数组长度N：12。<br>
我先讲第一种，比较普遍的都讲的是这一种。
## 快速排序（一）
定义标记i=0，j=11，基准k=10。<br>
（1）while(j-->i) if(a[j]<k) a[i] = a[j] break;<br>
（2）while(i++<j) if(a[i]>k) a[j] = a[i] break;<br>
以上循环break之后交替进行，直到i=j；然后a[i]/a[j] = k;<br>
以上完成了第一趟排序，然后就是按照上面的规则分别对k左边和右边递归执行；<br>
第一趟；<br>
k = 10;<br>
a:5，1，2，11，3，12，13，4，14，15，X，16。<br>
a:5，1，2，X，3，12，13，4，14，15，11，16。<br>
a:5，1，2，4，3，12，13，X，14，15，11，16。<br>
a:5，1，2，4，3，X，13，12，14，15，11，16。<br>
令X=K;<br>
第一趟结果：a:5，1，2，4，3，10，13，12，14，15，11，16。<br>
后边都是一样，分开之后分别递归。

然后讲一讲看到的另一种排序思路。
## 快速排序（二）
定义标记i=0，j=11，基准k=10。<br>
（1）
```
while(j-->i)
  if(a[j]<k)
    break;
```
（2）
```
while(i++<j)
  if(a[i]>k)
    break;
```
（3）
```
temp = a[j]
a[j]=a[i]
a[i]=temp;
```
（很简单的一个二值交换）<br>
（4）to （1）直到i=j；<br>
（5）
```
a[0] = a[i]/a[j]
a[i]/a[j] = k
```
（注意：为了保证最后与a[0]交换的值一定比a[0]小，所以一定是j先变化。）<br>
第一趟；<br>
红色：i；<br>
蓝色：j；<br>
绿色：汇合点；<br>
浅蓝色：基准；<br>
k = 10;<br>
a:10，1，2，<font color="#FF0000">5</font>，3，12，13，4，14，15，<font color="#0000FF">11</font>，16。11<-->5<br>
a:10，1，2，5，3，<font color="#FF0000">4</font>，13，<font color="#0000FF">12</font>，14，15，11，16。12<-->4<br>
a:<font color="#00FFFF">10</font>，1，2，5，3，<font color="#88FF">4</font>，13，12，14，15，11，16。<br>
a:<font color="#88FF">4</font>，1，2，5，3，<font color="#00FFFF">10</font>，13，12，14，15，11，16。10<-->4<br>
第一趟结果：a:4，1，2，5，3，10，13，12，14，15，11，16。<br>
后边都是一样，分开之后分别递归。

# 我们来对比一下
第一种：5，1，2，4，3，10，13，12，14，15，11，16。<br>
第二种：4，1，2，5，3，10，13，12，14，15，11，16。<br>
<img src='https://dawn1432.github.io\images\排序与查找\快速排序\无奈.jpg' align='margin-left' style=' width:75px;height:75px;margin:0;'/><br>

然鹅，这种固定选择基准的方法似乎在某些情况下并不能达到一个很好的排序效率，比如数组本来就是有序的，或者数组中存在重复元素。为应对这些问题，针对快排又提出了一些优化方案。
### 基元选择优化
## （一）随机基元选择
因为随机选取基元，所以不会总是出现劣割裂分隔，在一定程度上解决了顺序数组下的排序效率问题。
## （二）三数取中
原数组：<br>
a:10，1，2，11，3，12，13，4，14，15，5，16。<br>
（1）选择3个数a[0]=10，a[（N-1）/2]=12，a[N-1]=16。<br>
（2）对选择的3个数排序，这里刚好有序。<br>
（3）将中值a[（N-1）/2]=12放到数组首部。<br>
a:10，12，1，2，11，3，13，4，14，15，5，16。<br>
（4）除开已选择的3个数，对数组进行双向扫描，从左寻找比中值大的数，从右寻找比中值小的数，两两交换，最后将指针汇合点与中值交换。右边的指针先动。<br>
（注意：为了保证最后与中值交换的值一定比中值小，所以一定是j先变化。）<br>
第一趟；<br>
红色：i；<br>
蓝色：j；<br>
绿色：汇合点；<br>
浅蓝色：中值；<br>
a:10，12，1，2，11，3，<font color="#FF0000">13</font>，4，14，15，<font color="#0000FF">5</font>，16。<br>
a:10，<font color="#00FFFF">12</font>，1，2，11，3，5，<font color="#88FF">4</font>，14，15，13，16。13<-->5<br>
a:10，4，1，2，11，3，5，12，14，15，13，16。12<-->4<br>
（5）然后左右递归执行。<br>
三数取中有效地解决了顺序数组的排序效率，但是还是无法处理重复数组。
### 优化方法
## （一）三数取中+插入排序
当排序序列长度效率某一个值时，快排并没有插入排序效率高，通常我们选择N=10；所以，当子序列长度小于等于10时，使用插入排序。<br>
但是仍然不能处理重复数组。
## （二）三数取中+插入排序+key值聚合
在以上的模式下，每趟排序之后将key聚合到key的周围可以大大解决重复数组对排序效率的影响。<br>
<img src='https://dawn1432.github.io\images\排序与查找\快速排序\快排测试数据.png' align='margin-left' style=' width:75px;height:75px;margin:0;'/><br>
数据来自：[https://yq.aliyun.com/ziliao/384039](https://yq.aliyun.com/ziliao/384039)
